<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>fastapi_sso.sso.base API documentation</title>
<meta name="description" content="SSO login base dependency" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>fastapi_sso.sso.base</code></h1>
</header>
<section id="section-intro">
<p>SSO login base dependency</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;SSO login base dependency
&#34;&#34;&#34;
# pylint: disable=too-few-public-methods

import json
import sys
import warnings
from types import TracebackType
from typing import Any, Dict, List, Optional, Type

import httpx
import pydantic
from oauthlib.oauth2 import WebApplicationClient
from starlette.exceptions import HTTPException
from starlette.requests import Request
from starlette.responses import RedirectResponse

if sys.version_info &gt;= (3, 8):
    from typing import TypedDict
else:
    from typing_extensions import TypedDict  # pragma: no cover

if sys.version_info &gt;= (3, 11):
    from typing import NotRequired
else:
    from typing_extensions import NotRequired  # pragma: no cover

DiscoveryDocument = TypedDict(
    &#34;DiscoveryDocument&#34;,
    {
        &#34;authorization_endpoint&#34;: str,
        &#34;token_endpoint&#34;: str,
        &#34;userinfo_endpoint&#34;: str,
        &#34;emails_endpoint&#34;: NotRequired[str],
    },
)


class UnsetStateWarning(UserWarning):
    &#34;&#34;&#34;Warning about unset state parameter&#34;&#34;&#34;


class ReusedOauthClientWarning(UserWarning):
    &#34;&#34;&#34;Warning about reused oauth client instance&#34;&#34;&#34;


class SSOLoginError(HTTPException):
    &#34;&#34;&#34;Raised when any login-related error ocurrs
    (such as when user is not verified or if there was an attempt for fake login)
    &#34;&#34;&#34;


class OpenID(pydantic.BaseModel):  # pylint: disable=no-member
    &#34;&#34;&#34;Class (schema) to represent information got from sso provider in a common form.&#34;&#34;&#34;

    id: Optional[str] = None
    email: Optional[str] = None
    first_name: Optional[str] = None
    last_name: Optional[str] = None
    display_name: Optional[str] = None
    picture: Optional[str] = None
    provider: Optional[str] = None


# pylint: disable=too-many-instance-attributes
class SSOBase:
    &#34;&#34;&#34;Base class (mixin) for all SSO providers&#34;&#34;&#34;

    provider: str = NotImplemented
    client_id: str = NotImplemented
    client_secret: str = NotImplemented
    redirect_uri: Optional[str] = NotImplemented
    scope: List[str] = NotImplemented
    additional_headers: Optional[Dict[str, Any]] = None

    def __init__(
        self,
        client_id: str,
        client_secret: str,
        redirect_uri: Optional[str] = None,
        allow_insecure_http: bool = False,
        use_state: bool = False,
        scope: Optional[List[str]] = None,
    ):
        # pylint: disable=too-many-arguments
        self.client_id = client_id
        self.client_secret = client_secret
        self.redirect_uri = redirect_uri
        self.allow_insecure_http = allow_insecure_http
        self._oauth_client: Optional[WebApplicationClient] = None
        # TODO: Remove use_state argument and attribute
        if use_state:
            warnings.warn(
                (
                    &#34;Argument &#39;use_state&#39; of SSOBase&#39;s constructor is deprecated and will be removed in &#34;
                    &#34;future releases. Use &#39;state&#39; argument of individual methods instead.&#34;
                ),
                DeprecationWarning,
            )
        self.scope = scope or self.scope
        self._refresh_token: Optional[str] = None
        self._state: Optional[str] = None

    @property
    def state(self) -&gt; Optional[str]:
        &#34;&#34;&#34;Gets state as it was returned from the server&#34;&#34;&#34;
        if self._state is None:
            warnings.warn(
                &#34;&#39;state&#39; parameter is unset. This means the server either &#34;
                &#34;didn&#39;t return state (was this expected?) or &#39;verify_and_process&#39; hasn&#39;t been called yet.&#34;,
                UnsetStateWarning,
            )
        return self._state

    @property
    def oauth_client(self) -&gt; WebApplicationClient:
        &#34;&#34;&#34;OAuth Client to help us generate requests and parse responses&#34;&#34;&#34;
        if self.client_id == NotImplemented:
            raise NotImplementedError(f&#34;Provider {self.provider} not supported&#34;)  # pragma: no cover
        if self._oauth_client is None:
            self._oauth_client = WebApplicationClient(self.client_id)
        return self._oauth_client

    @property
    def access_token(self) -&gt; Optional[str]:
        &#34;&#34;&#34;Access token from token endpoint&#34;&#34;&#34;
        return self.oauth_client.access_token

    @property
    def refresh_token(self) -&gt; Optional[str]:
        &#34;&#34;&#34;Get refresh token (if returned from provider)&#34;&#34;&#34;
        return self._refresh_token or self.oauth_client.refresh_token

    @classmethod
    async def openid_from_response(cls, response: dict) -&gt; OpenID:
        &#34;&#34;&#34;Return {OpenID} object from provider&#39;s user info endpoint response&#34;&#34;&#34;
        raise NotImplementedError(f&#34;Provider {cls.provider} not supported&#34;)

    async def get_discovery_document(self) -&gt; DiscoveryDocument:
        &#34;&#34;&#34;Get discovery document containing handy urls&#34;&#34;&#34;
        raise NotImplementedError(f&#34;Provider {self.provider} not supported&#34;)

    @property
    async def authorization_endpoint(self) -&gt; Optional[str]:
        &#34;&#34;&#34;Return `authorization_endpoint` from discovery document&#34;&#34;&#34;
        discovery = await self.get_discovery_document()
        return discovery.get(&#34;authorization_endpoint&#34;)

    @property
    async def token_endpoint(self) -&gt; Optional[str]:
        &#34;&#34;&#34;Return `token_endpoint` from discovery document&#34;&#34;&#34;
        discovery = await self.get_discovery_document()
        return discovery.get(&#34;token_endpoint&#34;)

    @property
    async def userinfo_endpoint(self) -&gt; Optional[str]:
        &#34;&#34;&#34;Return `userinfo_endpoint` from discovery document&#34;&#34;&#34;
        discovery = await self.get_discovery_document()
        return discovery.get(&#34;userinfo_endpoint&#34;)

    async def get_login_url(
        self,
        *,
        redirect_uri: Optional[str] = None,
        params: Optional[Dict[str, Any]] = None,
        state: Optional[str] = None,
    ) -&gt; str:
        &#34;&#34;&#34;Return prepared login url. This is low-level, see {get_login_redirect} instead.&#34;&#34;&#34;
        params = params or {}
        redirect_uri = redirect_uri or self.redirect_uri
        if redirect_uri is None:
            raise ValueError(&#34;redirect_uri must be provided, either at construction or request time&#34;)
        request_uri = self.oauth_client.prepare_request_uri(
            await self.authorization_endpoint, redirect_uri=redirect_uri, state=state, scope=self.scope, **params
        )
        return request_uri

    async def get_login_redirect(
        self,
        *,
        redirect_uri: Optional[str] = None,
        params: Optional[Dict[str, Any]] = None,
        state: Optional[str] = None,
    ) -&gt; RedirectResponse:
        &#34;&#34;&#34;Return redirect response by Stalette to login page of Oauth SSO provider

        Arguments:
            redirect_uri {Optional[str]} -- Override redirect_uri specified on this instance (default: None)
            params {Optional[Dict[str, Any]]} -- Add additional query parameters to the login request.
            state {Optional[str]} -- Add state parameter. This is useful if you want
                                    the server to return something specific back to you.

        Returns:
            RedirectResponse -- Starlette response (may directly be returned from FastAPI)
        &#34;&#34;&#34;
        login_uri = await self.get_login_url(redirect_uri=redirect_uri, params=params, state=state)
        response = RedirectResponse(login_uri, 303)
        return response

    async def verify_and_process(
        self,
        request: Request,
        *,
        params: Optional[Dict[str, Any]] = None,
        headers: Optional[Dict[str, Any]] = None,
        redirect_uri: Optional[str] = None,
    ) -&gt; Optional[OpenID]:
        &#34;&#34;&#34;Get FastAPI (Starlette) Request object and process login.
        This handler should be used for your /callback path.

        Arguments:
            request {Request} -- FastAPI request object (or Starlette)
            params {Optional[Dict[str, Any]]} -- Optional additional query parameters to pass to the provider

        Returns:
            Optional[OpenID] -- OpenID if the login was successfull
        &#34;&#34;&#34;
        headers = headers or {}
        code = request.query_params.get(&#34;code&#34;)
        if code is None:
            raise SSOLoginError(400, &#34;&#39;code&#39; parameter was not found in callback request&#34;)
        self._state = request.query_params.get(&#34;state&#34;)
        return await self.process_login(
            code, request, params=params, additional_headers=headers, redirect_uri=redirect_uri
        )

    async def get_extra_data(self, content: Dict, session: httpx.AsyncClient) -&gt; Dict:
        &#34;&#34;&#34;Each subclass can reimplement this method if extra data and checks are needed&#34;&#34;&#34;
        # just to avoid &#34;unused argument&#34; in pylint checks
        _ = session
        return content

    def __enter__(self) -&gt; &#34;SSOBase&#34;:
        self._oauth_client = None
        self._refresh_token = None
        return self

    def __exit__(
        self,
        _exc_type: Optional[Type[BaseException]],
        _exc_val: Optional[BaseException],
        _exc_tb: Optional[TracebackType],
    ) -&gt; None:
        return None

    async def process_login(
        self,
        code: str,
        request: Request,
        *,
        params: Optional[Dict[str, Any]] = None,
        additional_headers: Optional[Dict[str, Any]] = None,
        redirect_uri: Optional[str] = None,
    ) -&gt; Optional[OpenID]:
        &#34;&#34;&#34;This method should be called from callback endpoint to verify the user and request user info endpoint.
        This is low level, you should use {verify_and_process} instead.

        Arguments:
            params {Optional[Dict[str, Any]]} -- Optional additional query parameters to pass to the provider
            additional_headers {Optional[Dict[str, Any]]} -- Optional additional headers to be added to all requests
        &#34;&#34;&#34;
        # pylint: disable=too-many-locals
        if self._oauth_client is not None:  # pragma: no cover
            self._oauth_client = None
            self._refresh_token = None
            warnings.warn(
                (
                    &#34;Reusing the SSO object is not safe and caused a security issue in previous versions.&#34;
                    &#34;To make sure you don&#39;t see this warning, please use the SSO object as a context manager.&#34;
                ),
                ReusedOauthClientWarning,
            )
        params = params or {}
        additional_headers = additional_headers or {}
        additional_headers.update(self.additional_headers or {})
        url = request.url
        scheme = url.scheme
        if not self.allow_insecure_http and scheme != &#34;https&#34;:
            current_url = str(url).replace(&#34;http://&#34;, &#34;https://&#34;)
            scheme = &#34;https&#34;
        else:
            current_url = str(url)
        current_path = f&#34;{scheme}://{url.netloc}{url.path}&#34;

        token_url, headers, body = self.oauth_client.prepare_token_request(
            await self.token_endpoint,
            authorization_response=current_url,
            redirect_url=redirect_uri or self.redirect_uri or current_path,
            code=code,
            **params,
        )  # type: ignore

        if token_url is None:  # pragma: no cover
            return None

        headers.update(additional_headers)

        auth = httpx.BasicAuth(self.client_id, self.client_secret)
        async with httpx.AsyncClient() as session:
            response = await session.post(token_url, headers=headers, content=body, auth=auth)
            content = response.json()
            self._refresh_token = content.get(&#34;refresh_token&#34;)
            self.oauth_client.parse_request_body_response(json.dumps(content))

            uri, headers, _ = self.oauth_client.add_token(await self.userinfo_endpoint)
            response = await session.get(uri, headers=headers)
            content = await self.get_extra_data(response.json(), session)

        return await self.openid_from_response(content)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="fastapi_sso.sso.base.DiscoveryDocument"><code class="flex name class">
<span>class <span class="ident">DiscoveryDocument</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>dict() -&gt; new empty dictionary
dict(mapping) -&gt; new dictionary initialized from a mapping object's
(key, value) pairs
dict(iterable) -&gt; new dictionary initialized as if via:
d = {}
for k, v in iterable:
d[k] = v
dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs
in the keyword argument list.
For example:
dict(one=1, two=2)</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.dict</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fastapi_sso.sso.base.DiscoveryDocument.authorization_endpoint"><code class="name">var <span class="ident">authorization_endpoint</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fastapi_sso.sso.base.DiscoveryDocument.emails_endpoint"><code class="name">var <span class="ident">emails_endpoint</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fastapi_sso.sso.base.DiscoveryDocument.token_endpoint"><code class="name">var <span class="ident">token_endpoint</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fastapi_sso.sso.base.DiscoveryDocument.userinfo_endpoint"><code class="name">var <span class="ident">userinfo_endpoint</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fastapi_sso.sso.base.OpenID"><code class="flex name class">
<span>class <span class="ident">OpenID</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>Class (schema) to represent information got from sso provider in a common form.</p>
<p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises ValidationError if the input data cannot be parsed to form a valid model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OpenID(pydantic.BaseModel):  # pylint: disable=no-member
    &#34;&#34;&#34;Class (schema) to represent information got from sso provider in a common form.&#34;&#34;&#34;

    id: Optional[str] = None
    email: Optional[str] = None
    first_name: Optional[str] = None
    last_name: Optional[str] = None
    display_name: Optional[str] = None
    picture: Optional[str] = None
    provider: Optional[str] = None</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pydantic.main.BaseModel</li>
<li>pydantic.utils.Representation</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fastapi_sso.sso.base.OpenID.display_name"><code class="name">var <span class="ident">display_name</span> : Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fastapi_sso.sso.base.OpenID.email"><code class="name">var <span class="ident">email</span> : Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fastapi_sso.sso.base.OpenID.first_name"><code class="name">var <span class="ident">first_name</span> : Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fastapi_sso.sso.base.OpenID.id"><code class="name">var <span class="ident">id</span> : Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fastapi_sso.sso.base.OpenID.last_name"><code class="name">var <span class="ident">last_name</span> : Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fastapi_sso.sso.base.OpenID.picture"><code class="name">var <span class="ident">picture</span> : Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fastapi_sso.sso.base.OpenID.provider"><code class="name">var <span class="ident">provider</span> : Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fastapi_sso.sso.base.ReusedOauthClientWarning"><code class="flex name class">
<span>class <span class="ident">ReusedOauthClientWarning</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Warning about reused oauth client instance</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ReusedOauthClientWarning(UserWarning):
    &#34;&#34;&#34;Warning about reused oauth client instance&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.UserWarning</li>
<li>builtins.Warning</li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="fastapi_sso.sso.base.SSOBase"><code class="flex name class">
<span>class <span class="ident">SSOBase</span></span>
<span>(</span><span>client_id: str, client_secret: str, redirect_uri: Optional[str] = None, allow_insecure_http: bool = False, use_state: bool = False, scope: Optional[List[str]] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class (mixin) for all SSO providers</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SSOBase:
    &#34;&#34;&#34;Base class (mixin) for all SSO providers&#34;&#34;&#34;

    provider: str = NotImplemented
    client_id: str = NotImplemented
    client_secret: str = NotImplemented
    redirect_uri: Optional[str] = NotImplemented
    scope: List[str] = NotImplemented
    additional_headers: Optional[Dict[str, Any]] = None

    def __init__(
        self,
        client_id: str,
        client_secret: str,
        redirect_uri: Optional[str] = None,
        allow_insecure_http: bool = False,
        use_state: bool = False,
        scope: Optional[List[str]] = None,
    ):
        # pylint: disable=too-many-arguments
        self.client_id = client_id
        self.client_secret = client_secret
        self.redirect_uri = redirect_uri
        self.allow_insecure_http = allow_insecure_http
        self._oauth_client: Optional[WebApplicationClient] = None
        # TODO: Remove use_state argument and attribute
        if use_state:
            warnings.warn(
                (
                    &#34;Argument &#39;use_state&#39; of SSOBase&#39;s constructor is deprecated and will be removed in &#34;
                    &#34;future releases. Use &#39;state&#39; argument of individual methods instead.&#34;
                ),
                DeprecationWarning,
            )
        self.scope = scope or self.scope
        self._refresh_token: Optional[str] = None
        self._state: Optional[str] = None

    @property
    def state(self) -&gt; Optional[str]:
        &#34;&#34;&#34;Gets state as it was returned from the server&#34;&#34;&#34;
        if self._state is None:
            warnings.warn(
                &#34;&#39;state&#39; parameter is unset. This means the server either &#34;
                &#34;didn&#39;t return state (was this expected?) or &#39;verify_and_process&#39; hasn&#39;t been called yet.&#34;,
                UnsetStateWarning,
            )
        return self._state

    @property
    def oauth_client(self) -&gt; WebApplicationClient:
        &#34;&#34;&#34;OAuth Client to help us generate requests and parse responses&#34;&#34;&#34;
        if self.client_id == NotImplemented:
            raise NotImplementedError(f&#34;Provider {self.provider} not supported&#34;)  # pragma: no cover
        if self._oauth_client is None:
            self._oauth_client = WebApplicationClient(self.client_id)
        return self._oauth_client

    @property
    def access_token(self) -&gt; Optional[str]:
        &#34;&#34;&#34;Access token from token endpoint&#34;&#34;&#34;
        return self.oauth_client.access_token

    @property
    def refresh_token(self) -&gt; Optional[str]:
        &#34;&#34;&#34;Get refresh token (if returned from provider)&#34;&#34;&#34;
        return self._refresh_token or self.oauth_client.refresh_token

    @classmethod
    async def openid_from_response(cls, response: dict) -&gt; OpenID:
        &#34;&#34;&#34;Return {OpenID} object from provider&#39;s user info endpoint response&#34;&#34;&#34;
        raise NotImplementedError(f&#34;Provider {cls.provider} not supported&#34;)

    async def get_discovery_document(self) -&gt; DiscoveryDocument:
        &#34;&#34;&#34;Get discovery document containing handy urls&#34;&#34;&#34;
        raise NotImplementedError(f&#34;Provider {self.provider} not supported&#34;)

    @property
    async def authorization_endpoint(self) -&gt; Optional[str]:
        &#34;&#34;&#34;Return `authorization_endpoint` from discovery document&#34;&#34;&#34;
        discovery = await self.get_discovery_document()
        return discovery.get(&#34;authorization_endpoint&#34;)

    @property
    async def token_endpoint(self) -&gt; Optional[str]:
        &#34;&#34;&#34;Return `token_endpoint` from discovery document&#34;&#34;&#34;
        discovery = await self.get_discovery_document()
        return discovery.get(&#34;token_endpoint&#34;)

    @property
    async def userinfo_endpoint(self) -&gt; Optional[str]:
        &#34;&#34;&#34;Return `userinfo_endpoint` from discovery document&#34;&#34;&#34;
        discovery = await self.get_discovery_document()
        return discovery.get(&#34;userinfo_endpoint&#34;)

    async def get_login_url(
        self,
        *,
        redirect_uri: Optional[str] = None,
        params: Optional[Dict[str, Any]] = None,
        state: Optional[str] = None,
    ) -&gt; str:
        &#34;&#34;&#34;Return prepared login url. This is low-level, see {get_login_redirect} instead.&#34;&#34;&#34;
        params = params or {}
        redirect_uri = redirect_uri or self.redirect_uri
        if redirect_uri is None:
            raise ValueError(&#34;redirect_uri must be provided, either at construction or request time&#34;)
        request_uri = self.oauth_client.prepare_request_uri(
            await self.authorization_endpoint, redirect_uri=redirect_uri, state=state, scope=self.scope, **params
        )
        return request_uri

    async def get_login_redirect(
        self,
        *,
        redirect_uri: Optional[str] = None,
        params: Optional[Dict[str, Any]] = None,
        state: Optional[str] = None,
    ) -&gt; RedirectResponse:
        &#34;&#34;&#34;Return redirect response by Stalette to login page of Oauth SSO provider

        Arguments:
            redirect_uri {Optional[str]} -- Override redirect_uri specified on this instance (default: None)
            params {Optional[Dict[str, Any]]} -- Add additional query parameters to the login request.
            state {Optional[str]} -- Add state parameter. This is useful if you want
                                    the server to return something specific back to you.

        Returns:
            RedirectResponse -- Starlette response (may directly be returned from FastAPI)
        &#34;&#34;&#34;
        login_uri = await self.get_login_url(redirect_uri=redirect_uri, params=params, state=state)
        response = RedirectResponse(login_uri, 303)
        return response

    async def verify_and_process(
        self,
        request: Request,
        *,
        params: Optional[Dict[str, Any]] = None,
        headers: Optional[Dict[str, Any]] = None,
        redirect_uri: Optional[str] = None,
    ) -&gt; Optional[OpenID]:
        &#34;&#34;&#34;Get FastAPI (Starlette) Request object and process login.
        This handler should be used for your /callback path.

        Arguments:
            request {Request} -- FastAPI request object (or Starlette)
            params {Optional[Dict[str, Any]]} -- Optional additional query parameters to pass to the provider

        Returns:
            Optional[OpenID] -- OpenID if the login was successfull
        &#34;&#34;&#34;
        headers = headers or {}
        code = request.query_params.get(&#34;code&#34;)
        if code is None:
            raise SSOLoginError(400, &#34;&#39;code&#39; parameter was not found in callback request&#34;)
        self._state = request.query_params.get(&#34;state&#34;)
        return await self.process_login(
            code, request, params=params, additional_headers=headers, redirect_uri=redirect_uri
        )

    async def get_extra_data(self, content: Dict, session: httpx.AsyncClient) -&gt; Dict:
        &#34;&#34;&#34;Each subclass can reimplement this method if extra data and checks are needed&#34;&#34;&#34;
        # just to avoid &#34;unused argument&#34; in pylint checks
        _ = session
        return content

    def __enter__(self) -&gt; &#34;SSOBase&#34;:
        self._oauth_client = None
        self._refresh_token = None
        return self

    def __exit__(
        self,
        _exc_type: Optional[Type[BaseException]],
        _exc_val: Optional[BaseException],
        _exc_tb: Optional[TracebackType],
    ) -&gt; None:
        return None

    async def process_login(
        self,
        code: str,
        request: Request,
        *,
        params: Optional[Dict[str, Any]] = None,
        additional_headers: Optional[Dict[str, Any]] = None,
        redirect_uri: Optional[str] = None,
    ) -&gt; Optional[OpenID]:
        &#34;&#34;&#34;This method should be called from callback endpoint to verify the user and request user info endpoint.
        This is low level, you should use {verify_and_process} instead.

        Arguments:
            params {Optional[Dict[str, Any]]} -- Optional additional query parameters to pass to the provider
            additional_headers {Optional[Dict[str, Any]]} -- Optional additional headers to be added to all requests
        &#34;&#34;&#34;
        # pylint: disable=too-many-locals
        if self._oauth_client is not None:  # pragma: no cover
            self._oauth_client = None
            self._refresh_token = None
            warnings.warn(
                (
                    &#34;Reusing the SSO object is not safe and caused a security issue in previous versions.&#34;
                    &#34;To make sure you don&#39;t see this warning, please use the SSO object as a context manager.&#34;
                ),
                ReusedOauthClientWarning,
            )
        params = params or {}
        additional_headers = additional_headers or {}
        additional_headers.update(self.additional_headers or {})
        url = request.url
        scheme = url.scheme
        if not self.allow_insecure_http and scheme != &#34;https&#34;:
            current_url = str(url).replace(&#34;http://&#34;, &#34;https://&#34;)
            scheme = &#34;https&#34;
        else:
            current_url = str(url)
        current_path = f&#34;{scheme}://{url.netloc}{url.path}&#34;

        token_url, headers, body = self.oauth_client.prepare_token_request(
            await self.token_endpoint,
            authorization_response=current_url,
            redirect_url=redirect_uri or self.redirect_uri or current_path,
            code=code,
            **params,
        )  # type: ignore

        if token_url is None:  # pragma: no cover
            return None

        headers.update(additional_headers)

        auth = httpx.BasicAuth(self.client_id, self.client_secret)
        async with httpx.AsyncClient() as session:
            response = await session.post(token_url, headers=headers, content=body, auth=auth)
            content = response.json()
            self._refresh_token = content.get(&#34;refresh_token&#34;)
            self.oauth_client.parse_request_body_response(json.dumps(content))

            uri, headers, _ = self.oauth_client.add_token(await self.userinfo_endpoint)
            response = await session.get(uri, headers=headers)
            content = await self.get_extra_data(response.json(), session)

        return await self.openid_from_response(content)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fastapi_sso.sso.facebook.FacebookSSO" href="facebook.html#fastapi_sso.sso.facebook.FacebookSSO">FacebookSSO</a></li>
<li><a title="fastapi_sso.sso.fitbit.FitbitSSO" href="fitbit.html#fastapi_sso.sso.fitbit.FitbitSSO">FitbitSSO</a></li>
<li><a title="fastapi_sso.sso.github.GithubSSO" href="github.html#fastapi_sso.sso.github.GithubSSO">GithubSSO</a></li>
<li><a title="fastapi_sso.sso.gitlab.GitlabSSO" href="gitlab.html#fastapi_sso.sso.gitlab.GitlabSSO">GitlabSSO</a></li>
<li><a title="fastapi_sso.sso.google.GoogleSSO" href="google.html#fastapi_sso.sso.google.GoogleSSO">GoogleSSO</a></li>
<li><a title="fastapi_sso.sso.kakao.KakaoSSO" href="kakao.html#fastapi_sso.sso.kakao.KakaoSSO">KakaoSSO</a></li>
<li><a title="fastapi_sso.sso.microsoft.MicrosoftSSO" href="microsoft.html#fastapi_sso.sso.microsoft.MicrosoftSSO">MicrosoftSSO</a></li>
<li><a title="fastapi_sso.sso.naver.NaverSSO" href="naver.html#fastapi_sso.sso.naver.NaverSSO">NaverSSO</a></li>
<li><a title="fastapi_sso.sso.spotify.SpotifySSO" href="spotify.html#fastapi_sso.sso.spotify.SpotifySSO">SpotifySSO</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fastapi_sso.sso.base.SSOBase.additional_headers"><code class="name">var <span class="ident">additional_headers</span> : Optional[Dict[str, Any]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fastapi_sso.sso.base.SSOBase.client_id"><code class="name">var <span class="ident">client_id</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fastapi_sso.sso.base.SSOBase.client_secret"><code class="name">var <span class="ident">client_secret</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fastapi_sso.sso.base.SSOBase.provider"><code class="name">var <span class="ident">provider</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fastapi_sso.sso.base.SSOBase.redirect_uri"><code class="name">var <span class="ident">redirect_uri</span> : Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fastapi_sso.sso.base.SSOBase.scope"><code class="name">var <span class="ident">scope</span> : List[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="fastapi_sso.sso.base.SSOBase.openid_from_response"><code class="name flex">
<span>async def <span class="ident">openid_from_response</span></span>(<span>response: dict) ‑> <a title="fastapi_sso.sso.base.OpenID" href="#fastapi_sso.sso.base.OpenID">OpenID</a></span>
</code></dt>
<dd>
<div class="desc"><p>Return {OpenID} object from provider's user info endpoint response</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
async def openid_from_response(cls, response: dict) -&gt; OpenID:
    &#34;&#34;&#34;Return {OpenID} object from provider&#39;s user info endpoint response&#34;&#34;&#34;
    raise NotImplementedError(f&#34;Provider {cls.provider} not supported&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="fastapi_sso.sso.base.SSOBase.access_token"><code class="name">var <span class="ident">access_token</span> : Optional[str]</code></dt>
<dd>
<div class="desc"><p>Access token from token endpoint</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def access_token(self) -&gt; Optional[str]:
    &#34;&#34;&#34;Access token from token endpoint&#34;&#34;&#34;
    return self.oauth_client.access_token</code></pre>
</details>
</dd>
<dt id="fastapi_sso.sso.base.SSOBase.authorization_endpoint"><code class="name">var <span class="ident">authorization_endpoint</span> : Optional[str]</code></dt>
<dd>
<div class="desc"><p>Return <code>authorization_endpoint</code> from discovery document</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
async def authorization_endpoint(self) -&gt; Optional[str]:
    &#34;&#34;&#34;Return `authorization_endpoint` from discovery document&#34;&#34;&#34;
    discovery = await self.get_discovery_document()
    return discovery.get(&#34;authorization_endpoint&#34;)</code></pre>
</details>
</dd>
<dt id="fastapi_sso.sso.base.SSOBase.oauth_client"><code class="name">var <span class="ident">oauth_client</span> : oauthlib.oauth2.rfc6749.clients.web_application.WebApplicationClient</code></dt>
<dd>
<div class="desc"><p>OAuth Client to help us generate requests and parse responses</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def oauth_client(self) -&gt; WebApplicationClient:
    &#34;&#34;&#34;OAuth Client to help us generate requests and parse responses&#34;&#34;&#34;
    if self.client_id == NotImplemented:
        raise NotImplementedError(f&#34;Provider {self.provider} not supported&#34;)  # pragma: no cover
    if self._oauth_client is None:
        self._oauth_client = WebApplicationClient(self.client_id)
    return self._oauth_client</code></pre>
</details>
</dd>
<dt id="fastapi_sso.sso.base.SSOBase.refresh_token"><code class="name">var <span class="ident">refresh_token</span> : Optional[str]</code></dt>
<dd>
<div class="desc"><p>Get refresh token (if returned from provider)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def refresh_token(self) -&gt; Optional[str]:
    &#34;&#34;&#34;Get refresh token (if returned from provider)&#34;&#34;&#34;
    return self._refresh_token or self.oauth_client.refresh_token</code></pre>
</details>
</dd>
<dt id="fastapi_sso.sso.base.SSOBase.state"><code class="name">var <span class="ident">state</span> : Optional[str]</code></dt>
<dd>
<div class="desc"><p>Gets state as it was returned from the server</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def state(self) -&gt; Optional[str]:
    &#34;&#34;&#34;Gets state as it was returned from the server&#34;&#34;&#34;
    if self._state is None:
        warnings.warn(
            &#34;&#39;state&#39; parameter is unset. This means the server either &#34;
            &#34;didn&#39;t return state (was this expected?) or &#39;verify_and_process&#39; hasn&#39;t been called yet.&#34;,
            UnsetStateWarning,
        )
    return self._state</code></pre>
</details>
</dd>
<dt id="fastapi_sso.sso.base.SSOBase.token_endpoint"><code class="name">var <span class="ident">token_endpoint</span> : Optional[str]</code></dt>
<dd>
<div class="desc"><p>Return <code>token_endpoint</code> from discovery document</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
async def token_endpoint(self) -&gt; Optional[str]:
    &#34;&#34;&#34;Return `token_endpoint` from discovery document&#34;&#34;&#34;
    discovery = await self.get_discovery_document()
    return discovery.get(&#34;token_endpoint&#34;)</code></pre>
</details>
</dd>
<dt id="fastapi_sso.sso.base.SSOBase.userinfo_endpoint"><code class="name">var <span class="ident">userinfo_endpoint</span> : Optional[str]</code></dt>
<dd>
<div class="desc"><p>Return <code>userinfo_endpoint</code> from discovery document</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
async def userinfo_endpoint(self) -&gt; Optional[str]:
    &#34;&#34;&#34;Return `userinfo_endpoint` from discovery document&#34;&#34;&#34;
    discovery = await self.get_discovery_document()
    return discovery.get(&#34;userinfo_endpoint&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fastapi_sso.sso.base.SSOBase.get_discovery_document"><code class="name flex">
<span>async def <span class="ident">get_discovery_document</span></span>(<span>self) ‑> <a title="fastapi_sso.sso.base.DiscoveryDocument" href="#fastapi_sso.sso.base.DiscoveryDocument">DiscoveryDocument</a></span>
</code></dt>
<dd>
<div class="desc"><p>Get discovery document containing handy urls</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_discovery_document(self) -&gt; DiscoveryDocument:
    &#34;&#34;&#34;Get discovery document containing handy urls&#34;&#34;&#34;
    raise NotImplementedError(f&#34;Provider {self.provider} not supported&#34;)</code></pre>
</details>
</dd>
<dt id="fastapi_sso.sso.base.SSOBase.get_extra_data"><code class="name flex">
<span>async def <span class="ident">get_extra_data</span></span>(<span>self, content: Dict, session: httpx.AsyncClient) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Each subclass can reimplement this method if extra data and checks are needed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_extra_data(self, content: Dict, session: httpx.AsyncClient) -&gt; Dict:
    &#34;&#34;&#34;Each subclass can reimplement this method if extra data and checks are needed&#34;&#34;&#34;
    # just to avoid &#34;unused argument&#34; in pylint checks
    _ = session
    return content</code></pre>
</details>
</dd>
<dt id="fastapi_sso.sso.base.SSOBase.get_login_redirect"><code class="name flex">
<span>async def <span class="ident">get_login_redirect</span></span>(<span>self, *, redirect_uri: Optional[str] = None, params: Optional[Dict[str, Any]] = None, state: Optional[str] = None) ‑> starlette.responses.RedirectResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Return redirect response by Stalette to login page of Oauth SSO provider</p>
<h2 id="arguments">Arguments</h2>
<p>redirect_uri {Optional[str]} &ndash; Override redirect_uri specified on this instance (default: None)
params {Optional[Dict[str, Any]]} &ndash; Add additional query parameters to the login request.
state {Optional[str]} &ndash; Add state parameter. This is useful if you want
the server to return something specific back to you.</p>
<h2 id="returns">Returns</h2>
<p>RedirectResponse &ndash; Starlette response (may directly be returned from FastAPI)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_login_redirect(
    self,
    *,
    redirect_uri: Optional[str] = None,
    params: Optional[Dict[str, Any]] = None,
    state: Optional[str] = None,
) -&gt; RedirectResponse:
    &#34;&#34;&#34;Return redirect response by Stalette to login page of Oauth SSO provider

    Arguments:
        redirect_uri {Optional[str]} -- Override redirect_uri specified on this instance (default: None)
        params {Optional[Dict[str, Any]]} -- Add additional query parameters to the login request.
        state {Optional[str]} -- Add state parameter. This is useful if you want
                                the server to return something specific back to you.

    Returns:
        RedirectResponse -- Starlette response (may directly be returned from FastAPI)
    &#34;&#34;&#34;
    login_uri = await self.get_login_url(redirect_uri=redirect_uri, params=params, state=state)
    response = RedirectResponse(login_uri, 303)
    return response</code></pre>
</details>
</dd>
<dt id="fastapi_sso.sso.base.SSOBase.get_login_url"><code class="name flex">
<span>async def <span class="ident">get_login_url</span></span>(<span>self, *, redirect_uri: Optional[str] = None, params: Optional[Dict[str, Any]] = None, state: Optional[str] = None) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Return prepared login url. This is low-level, see {get_login_redirect} instead.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_login_url(
    self,
    *,
    redirect_uri: Optional[str] = None,
    params: Optional[Dict[str, Any]] = None,
    state: Optional[str] = None,
) -&gt; str:
    &#34;&#34;&#34;Return prepared login url. This is low-level, see {get_login_redirect} instead.&#34;&#34;&#34;
    params = params or {}
    redirect_uri = redirect_uri or self.redirect_uri
    if redirect_uri is None:
        raise ValueError(&#34;redirect_uri must be provided, either at construction or request time&#34;)
    request_uri = self.oauth_client.prepare_request_uri(
        await self.authorization_endpoint, redirect_uri=redirect_uri, state=state, scope=self.scope, **params
    )
    return request_uri</code></pre>
</details>
</dd>
<dt id="fastapi_sso.sso.base.SSOBase.process_login"><code class="name flex">
<span>async def <span class="ident">process_login</span></span>(<span>self, code: str, request: starlette.requests.Request, *, params: Optional[Dict[str, Any]] = None, additional_headers: Optional[Dict[str, Any]] = None, redirect_uri: Optional[str] = None) ‑> Optional[<a title="fastapi_sso.sso.base.OpenID" href="#fastapi_sso.sso.base.OpenID">OpenID</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>This method should be called from callback endpoint to verify the user and request user info endpoint.
This is low level, you should use {verify_and_process} instead.</p>
<h2 id="arguments">Arguments</h2>
<p>params {Optional[Dict[str, Any]]} &ndash; Optional additional query parameters to pass to the provider
additional_headers {Optional[Dict[str, Any]]} &ndash; Optional additional headers to be added to all requests</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def process_login(
    self,
    code: str,
    request: Request,
    *,
    params: Optional[Dict[str, Any]] = None,
    additional_headers: Optional[Dict[str, Any]] = None,
    redirect_uri: Optional[str] = None,
) -&gt; Optional[OpenID]:
    &#34;&#34;&#34;This method should be called from callback endpoint to verify the user and request user info endpoint.
    This is low level, you should use {verify_and_process} instead.

    Arguments:
        params {Optional[Dict[str, Any]]} -- Optional additional query parameters to pass to the provider
        additional_headers {Optional[Dict[str, Any]]} -- Optional additional headers to be added to all requests
    &#34;&#34;&#34;
    # pylint: disable=too-many-locals
    if self._oauth_client is not None:  # pragma: no cover
        self._oauth_client = None
        self._refresh_token = None
        warnings.warn(
            (
                &#34;Reusing the SSO object is not safe and caused a security issue in previous versions.&#34;
                &#34;To make sure you don&#39;t see this warning, please use the SSO object as a context manager.&#34;
            ),
            ReusedOauthClientWarning,
        )
    params = params or {}
    additional_headers = additional_headers or {}
    additional_headers.update(self.additional_headers or {})
    url = request.url
    scheme = url.scheme
    if not self.allow_insecure_http and scheme != &#34;https&#34;:
        current_url = str(url).replace(&#34;http://&#34;, &#34;https://&#34;)
        scheme = &#34;https&#34;
    else:
        current_url = str(url)
    current_path = f&#34;{scheme}://{url.netloc}{url.path}&#34;

    token_url, headers, body = self.oauth_client.prepare_token_request(
        await self.token_endpoint,
        authorization_response=current_url,
        redirect_url=redirect_uri or self.redirect_uri or current_path,
        code=code,
        **params,
    )  # type: ignore

    if token_url is None:  # pragma: no cover
        return None

    headers.update(additional_headers)

    auth = httpx.BasicAuth(self.client_id, self.client_secret)
    async with httpx.AsyncClient() as session:
        response = await session.post(token_url, headers=headers, content=body, auth=auth)
        content = response.json()
        self._refresh_token = content.get(&#34;refresh_token&#34;)
        self.oauth_client.parse_request_body_response(json.dumps(content))

        uri, headers, _ = self.oauth_client.add_token(await self.userinfo_endpoint)
        response = await session.get(uri, headers=headers)
        content = await self.get_extra_data(response.json(), session)

    return await self.openid_from_response(content)</code></pre>
</details>
</dd>
<dt id="fastapi_sso.sso.base.SSOBase.verify_and_process"><code class="name flex">
<span>async def <span class="ident">verify_and_process</span></span>(<span>self, request: starlette.requests.Request, *, params: Optional[Dict[str, Any]] = None, headers: Optional[Dict[str, Any]] = None, redirect_uri: Optional[str] = None) ‑> Optional[<a title="fastapi_sso.sso.base.OpenID" href="#fastapi_sso.sso.base.OpenID">OpenID</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Get FastAPI (Starlette) Request object and process login.
This handler should be used for your /callback path.</p>
<h2 id="arguments">Arguments</h2>
<p>request {Request} &ndash; FastAPI request object (or Starlette)
params {Optional[Dict[str, Any]]} &ndash; Optional additional query parameters to pass to the provider</p>
<h2 id="returns">Returns</h2>
<p>Optional[OpenID] &ndash; OpenID if the login was successfull</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def verify_and_process(
    self,
    request: Request,
    *,
    params: Optional[Dict[str, Any]] = None,
    headers: Optional[Dict[str, Any]] = None,
    redirect_uri: Optional[str] = None,
) -&gt; Optional[OpenID]:
    &#34;&#34;&#34;Get FastAPI (Starlette) Request object and process login.
    This handler should be used for your /callback path.

    Arguments:
        request {Request} -- FastAPI request object (or Starlette)
        params {Optional[Dict[str, Any]]} -- Optional additional query parameters to pass to the provider

    Returns:
        Optional[OpenID] -- OpenID if the login was successfull
    &#34;&#34;&#34;
    headers = headers or {}
    code = request.query_params.get(&#34;code&#34;)
    if code is None:
        raise SSOLoginError(400, &#34;&#39;code&#39; parameter was not found in callback request&#34;)
    self._state = request.query_params.get(&#34;state&#34;)
    return await self.process_login(
        code, request, params=params, additional_headers=headers, redirect_uri=redirect_uri
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="fastapi_sso.sso.base.SSOLoginError"><code class="flex name class">
<span>class <span class="ident">SSOLoginError</span></span>
<span>(</span><span>status_code: int, detail: Optional[str] = None, headers: Optional[dict] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Raised when any login-related error ocurrs
(such as when user is not verified or if there was an attempt for fake login)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SSOLoginError(HTTPException):
    &#34;&#34;&#34;Raised when any login-related error ocurrs
    (such as when user is not verified or if there was an attempt for fake login)
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>starlette.exceptions.HTTPException</li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="fastapi_sso.sso.base.UnsetStateWarning"><code class="flex name class">
<span>class <span class="ident">UnsetStateWarning</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Warning about unset state parameter</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UnsetStateWarning(UserWarning):
    &#34;&#34;&#34;Warning about unset state parameter&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.UserWarning</li>
<li>builtins.Warning</li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="fastapi_sso.sso" href="index.html">fastapi_sso.sso</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="fastapi_sso.sso.base.DiscoveryDocument" href="#fastapi_sso.sso.base.DiscoveryDocument">DiscoveryDocument</a></code></h4>
<ul class="">
<li><code><a title="fastapi_sso.sso.base.DiscoveryDocument.authorization_endpoint" href="#fastapi_sso.sso.base.DiscoveryDocument.authorization_endpoint">authorization_endpoint</a></code></li>
<li><code><a title="fastapi_sso.sso.base.DiscoveryDocument.emails_endpoint" href="#fastapi_sso.sso.base.DiscoveryDocument.emails_endpoint">emails_endpoint</a></code></li>
<li><code><a title="fastapi_sso.sso.base.DiscoveryDocument.token_endpoint" href="#fastapi_sso.sso.base.DiscoveryDocument.token_endpoint">token_endpoint</a></code></li>
<li><code><a title="fastapi_sso.sso.base.DiscoveryDocument.userinfo_endpoint" href="#fastapi_sso.sso.base.DiscoveryDocument.userinfo_endpoint">userinfo_endpoint</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fastapi_sso.sso.base.OpenID" href="#fastapi_sso.sso.base.OpenID">OpenID</a></code></h4>
<ul class="two-column">
<li><code><a title="fastapi_sso.sso.base.OpenID.display_name" href="#fastapi_sso.sso.base.OpenID.display_name">display_name</a></code></li>
<li><code><a title="fastapi_sso.sso.base.OpenID.email" href="#fastapi_sso.sso.base.OpenID.email">email</a></code></li>
<li><code><a title="fastapi_sso.sso.base.OpenID.first_name" href="#fastapi_sso.sso.base.OpenID.first_name">first_name</a></code></li>
<li><code><a title="fastapi_sso.sso.base.OpenID.id" href="#fastapi_sso.sso.base.OpenID.id">id</a></code></li>
<li><code><a title="fastapi_sso.sso.base.OpenID.last_name" href="#fastapi_sso.sso.base.OpenID.last_name">last_name</a></code></li>
<li><code><a title="fastapi_sso.sso.base.OpenID.picture" href="#fastapi_sso.sso.base.OpenID.picture">picture</a></code></li>
<li><code><a title="fastapi_sso.sso.base.OpenID.provider" href="#fastapi_sso.sso.base.OpenID.provider">provider</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fastapi_sso.sso.base.ReusedOauthClientWarning" href="#fastapi_sso.sso.base.ReusedOauthClientWarning">ReusedOauthClientWarning</a></code></h4>
</li>
<li>
<h4><code><a title="fastapi_sso.sso.base.SSOBase" href="#fastapi_sso.sso.base.SSOBase">SSOBase</a></code></h4>
<ul class="">
<li><code><a title="fastapi_sso.sso.base.SSOBase.access_token" href="#fastapi_sso.sso.base.SSOBase.access_token">access_token</a></code></li>
<li><code><a title="fastapi_sso.sso.base.SSOBase.additional_headers" href="#fastapi_sso.sso.base.SSOBase.additional_headers">additional_headers</a></code></li>
<li><code><a title="fastapi_sso.sso.base.SSOBase.authorization_endpoint" href="#fastapi_sso.sso.base.SSOBase.authorization_endpoint">authorization_endpoint</a></code></li>
<li><code><a title="fastapi_sso.sso.base.SSOBase.client_id" href="#fastapi_sso.sso.base.SSOBase.client_id">client_id</a></code></li>
<li><code><a title="fastapi_sso.sso.base.SSOBase.client_secret" href="#fastapi_sso.sso.base.SSOBase.client_secret">client_secret</a></code></li>
<li><code><a title="fastapi_sso.sso.base.SSOBase.get_discovery_document" href="#fastapi_sso.sso.base.SSOBase.get_discovery_document">get_discovery_document</a></code></li>
<li><code><a title="fastapi_sso.sso.base.SSOBase.get_extra_data" href="#fastapi_sso.sso.base.SSOBase.get_extra_data">get_extra_data</a></code></li>
<li><code><a title="fastapi_sso.sso.base.SSOBase.get_login_redirect" href="#fastapi_sso.sso.base.SSOBase.get_login_redirect">get_login_redirect</a></code></li>
<li><code><a title="fastapi_sso.sso.base.SSOBase.get_login_url" href="#fastapi_sso.sso.base.SSOBase.get_login_url">get_login_url</a></code></li>
<li><code><a title="fastapi_sso.sso.base.SSOBase.oauth_client" href="#fastapi_sso.sso.base.SSOBase.oauth_client">oauth_client</a></code></li>
<li><code><a title="fastapi_sso.sso.base.SSOBase.openid_from_response" href="#fastapi_sso.sso.base.SSOBase.openid_from_response">openid_from_response</a></code></li>
<li><code><a title="fastapi_sso.sso.base.SSOBase.process_login" href="#fastapi_sso.sso.base.SSOBase.process_login">process_login</a></code></li>
<li><code><a title="fastapi_sso.sso.base.SSOBase.provider" href="#fastapi_sso.sso.base.SSOBase.provider">provider</a></code></li>
<li><code><a title="fastapi_sso.sso.base.SSOBase.redirect_uri" href="#fastapi_sso.sso.base.SSOBase.redirect_uri">redirect_uri</a></code></li>
<li><code><a title="fastapi_sso.sso.base.SSOBase.refresh_token" href="#fastapi_sso.sso.base.SSOBase.refresh_token">refresh_token</a></code></li>
<li><code><a title="fastapi_sso.sso.base.SSOBase.scope" href="#fastapi_sso.sso.base.SSOBase.scope">scope</a></code></li>
<li><code><a title="fastapi_sso.sso.base.SSOBase.state" href="#fastapi_sso.sso.base.SSOBase.state">state</a></code></li>
<li><code><a title="fastapi_sso.sso.base.SSOBase.token_endpoint" href="#fastapi_sso.sso.base.SSOBase.token_endpoint">token_endpoint</a></code></li>
<li><code><a title="fastapi_sso.sso.base.SSOBase.userinfo_endpoint" href="#fastapi_sso.sso.base.SSOBase.userinfo_endpoint">userinfo_endpoint</a></code></li>
<li><code><a title="fastapi_sso.sso.base.SSOBase.verify_and_process" href="#fastapi_sso.sso.base.SSOBase.verify_and_process">verify_and_process</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fastapi_sso.sso.base.SSOLoginError" href="#fastapi_sso.sso.base.SSOLoginError">SSOLoginError</a></code></h4>
</li>
<li>
<h4><code><a title="fastapi_sso.sso.base.UnsetStateWarning" href="#fastapi_sso.sso.base.UnsetStateWarning">UnsetStateWarning</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>